---
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, options(readr.show_col_types = FALSE))
```

# Power re-calculations to determine the minimum odds ratios that can be estimated from different sample sizes

```{r}
library(epiR)
library(tidyverse)
library(pander)
library(gt)
```

## Power calculations for ENDIA

As described in [Oakey et al. 2023](https://doi.org/10.1080/07853890.2023.2198255), power calculations were done based on the NCC design of 50 case children and 150 matched (by sex and age) controls assuming a type I error of 0.05, power of 0.8 and a two-sided test and varying baseline probabilities between control children (p0) and correlation between matched controls and cases (phi) [Oakey et al. 2023](https://doi.org/10.1080/07853890.2023.2198255), supp info, page 2. 

However, in our manuscript, we report results from 44 case and 99 control samples (n = 143), a reduced number compared to the original design due to lack of plasma samples for the selected individuals or due to sample loss during processing at CDI labs. We also performed some of the analysis with a reduced dataset where we removed two controls that later developed IA (n = 141, cases = 44, controls = 97). 

To address these discrepancies, we have calculated the power of our study following the same approach as described in the original ENDIA NCC paper. 


```{r}
# assumptions obtained from Table A3 in Oakey et al. Supp info
p0_vals <- c(0.01, 0.05, 0.1, 0.2, 0.3)
phi_vals <- c(0, 0.1, 0.2, 0.3)

# function to calculate minimum detectable OR

min_detectable_or_matched <- function(p0, phi.coef, alpha = 0.05, power = 0.8,
                                      n_cases = 44, n_controls = 99) {
  total_n <- n_cases + n_controls
  ratio <- n_controls / n_cases

  tibble(or = seq(1.01, 20, by = 0.01)) %>%
    mutate(result = map(or, ~ epi.sscc(
      OR = .x,
      p0 = p0,
      n = total_n,
      power = NA,
      r = ratio,
      phi.coef = phi.coef,
      conf.level = 1 - alpha,
      method = "matched"))) %>%
    filter(map_lgl(result, ~ !is.null(.x$OR) && .x$power >= power)) %>%
    {
      if (nrow(.) == 0) { # return NA if no ORs meet the power threshold
        tibble(min_OR = NA_real_)
      } else {
        summarise(., min_OR = round(min(map_dbl(result, "OR")), 2))
      }
    } %>%
    pull(min_OR)
}
```

### Calculations for a total of 143 samples for ENDIA 

```{r}
# loop through all combinations and compute minimum detectable ORs
min_detect_OR_143 <- crossing(p0 = p0_vals, phi = phi_vals) %>% 
  mutate(min_OR = pmap_dbl(
    list(p0, phi),
    ~ min_detectable_or_matched(..1, ..2, n_cases = 44, n_controls = 99)))

# reshape and display results
min_detect_OR_143 %>%
  pivot_wider(names_from = phi, values_from = min_OR, names_prefix = "phi = ") %>%
  pander(round = 2, caption = "Minimum Detectable OR by p0 and phi")
```

### Calculations for 141 samples for ENDIA

```{r}
min_detect_OR_141 <- crossing(p0 = p0_vals, phi = phi_vals) %>% 
  mutate(min_OR = pmap_dbl(
    list(p0, phi),
    ~ min_detectable_or_matched(..1, ..2, n_cases = 44, n_controls = 97)))

# reshape and display results
min_detect_OR_141 %>%
  as_tibble() %>%
  pivot_wider(names_from = phi, values_from = min_OR) %>% 
  rename_with(~ paste0("phi = ", .x)) %>%
  pander(round = 2, caption = "Minimum Detectable OR by p0 and phi")
```

The minimum detectable OR for both 143 and 141 samples is around 2.83.

## Power calculations for VIGR

Following the same principles, we will calculate the power of the VIGR dataset (n = 42, cases = 21, controls = 21)

```{r}
min_detect_OR_vigr <- crossing(p0 = p0_vals, phi = phi_vals) %>% 
  mutate(min_OR = pmap_dbl(
    list(p0, phi),
    ~ min_detectable_or_matched(..1, ..2, n_cases = 21, n_controls = 21)))

# reshape and display results
min_detect_OR_vigr %>%
  as_tibble() %>%
  pivot_wider(names_from = phi, values_from = min_OR) %>% 
  rename_with(~ paste0("phi = ", .x)) %>%
  pander(round = 2, caption = "Minimum Detectable OR by p0 and phi")
```

For VIGR, the minimum detectable OR is 6.20 with 80% power, when the baseline exposure probability is 30% (p0 = 0.3) and the matching correlation phi is 0 (no dependence in exposure between matched cases and controls). This indicates that VIGR is underpowered compared to ENDIA as VIGR has 80% power to detect an odds ratio **only if it is 6.20 or greater**.

Note that when the exposure is 0.01 (p0 = 0.01), which is very low exposure prevalence (only ~1% controls are expected to be exposed, so if we have 21 controls, that's ~0.21 people, very close to 0 exposed people) we get `NA` values for phi because it cannot detect anything with this sample size (because the OR does not meet the power requirement) 
 
### Combined table with power calculation results for ENDIA with n = 143 and n = 141 and for VIGR (n = 42) for paper

**Supplementary Table 5:** Power calculations on the ENDIA, using both 143 samples (44 cases and 99 controls) and 141 samples (44 cases and 97 controls), and VIGR (21 cases and 21 controls) datasets. Minimum detectable odds ratios (ORs) were computed using the epi.sscc() function from the epiR v2.0.86 R package, iterating over OR values from 1.01 to 20, by increments of 0.01. The smallest OR achieving 80% power for each combination of p0 and phi was retained. The row containing the lowest p0 values is highlighted in yellow, where phi = 0.

```{r, echo = FALSE}
library(tidyverse)
library(gt)

# add dataset labels
min_detect_OR_143_labeled <- min_detect_OR_143 %>%
  mutate(dataset = "ENDIA_143")

min_detect_OR_141_labeled <- min_detect_OR_141 %>%
  mutate(dataset = "ENDIA_141")

min_detect_OR_vigr_labeled <- min_detect_OR_vigr %>%
  mutate(dataset = "VIGR")

# combine all into one long table
combined_results <- bind_rows(
  min_detect_OR_143_labeled,
  min_detect_OR_141_labeled,
  min_detect_OR_vigr_labeled
)

# pivot wider so each dataset is a column
wide_results <- combined_results %>%
  pivot_wider(
    names_from = dataset,
    values_from = min_OR
  )

power_calc_table_pretty <- wide_results %>%
  mutate(
    phi = paste0("ϕ: ", phi),
    p0 = paste0("p\u2080: ", p0) # unicode for subscript 0
  ) %>%
  arrange(p0, phi) %>%
  mutate(across(where(is.numeric), ~ round(.x, 2))) %>%
  gt(rowname_col = "p0", groupname_col = "phi") %>%
  tab_header(
    title = "Minimum detectable OR by p₀, ϕ, and dataset",
    subtitle = "80% power, α = 0.05"
  ) %>%
  cols_label(
  ENDIA_143 = html("ENDIA<br>(n = 143)"),
  ENDIA_141 = html("ENDIA<br>(n = 141)"),
  VIGR = html("VIGR<br>(n = 42)")
) %>%
  tab_style(
    style = list(
      cell_fill(color = "yellow"),
      cell_text(weight = "bold")
    ),
    locations = cells_body(
      rows = phi == "ϕ: 0" & p0 == "p₀: 0.3"
    )
  ) %>%
  tab_style(
    list(
      cell_fill(color = "grey"),
      cell_text(weight = "bold")
   ),
    locations = cells_row_groups()
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "yellow"),
      cell_text(weight = "bold")
    ),
    locations = cells_stub(
      rows = phi == "ϕ: 0" & p0 == "p₀: 0.3"
    )
  )

as_raw_html(power_calc_table_pretty)
```

```{r, echo = FALSE}
gtsave(power_calc_table_pretty, "figures/power_calc_table_table.png")
```

